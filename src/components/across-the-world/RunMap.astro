---
import 'leaflet/dist/leaflet.css';
import 'leaflet.markercluster/dist/MarkerCluster.css';
import 'leaflet.markercluster/dist/MarkerCluster.Default.css';

interface Props {
  dataUrl?: string;
}

const { dataUrl = '/data/run-locations.json' } = Astro.props;
---

<div class="map-wrapper">
  <div id="run-map" data-map-url={dataUrl}></div>
  <p id="run-map-error" class="map-error" hidden>
    Map data could not be loaded right now.
  </p>
</div>

<script>
  import L from 'leaflet';
  import 'leaflet.markercluster';

  function formatDistance(meters: number): string {
    const km = meters / 1000;
    return km >= 10 ? `${km.toFixed(0)} km` : `${km.toFixed(1)} km`;
  }

  function formatDuration(seconds: number): string {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    if (h > 0) return `${h}h ${m.toString().padStart(2, '0')}m`;
    return `${m}m`;
  }

  function formatPace(distance: number, movingTime: number): string {
    if (distance === 0 || movingTime === 0) return '—';
    const metersPerSecond = distance / movingTime;
    const minPerKm = 1000 / metersPerSecond / 60;
    const mins = Math.floor(minPerKm);
    const secs = Math.round((minPerKm - mins) * 60);
    return `${mins}:${secs.toString().padStart(2, '0')} /km`;
  }

  function escapeHtml(str: string): string {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function sanitizePopupMediaPath(path: string): string | null {
    const normalized = path.trim().replace(/^\/+/, '');
    if (!normalized || normalized.includes('..')) return null;
    if (!/^strava-media\/[A-Za-z0-9._/-]+$/.test(normalized)) return null;
    return normalized;
  }

  interface RunData {
    lat: number;
    lng: number;
    name: string;
    date: string;
    distance: number;
    moving_time: number;
    media: string[];
    gear: string;
  }

  interface RouteData {
    name: string;
    coordinates: [number, number][];
  }

  interface MapData {
    runs: RunData[];
    routes: RouteData[];
  }

  function showMapError(message: string) {
    const errorEl = document.getElementById('run-map-error');
    if (!errorEl) return;
    errorEl.textContent = message;
    errorEl.hidden = false;
  }

  function normalizeMapData(raw: unknown): MapData {
    if (!raw || typeof raw !== 'object') {
      return { runs: [], routes: [] };
    }
    const data = raw as Record<string, unknown>;
    return {
      runs: Array.isArray(data.runs) ? (data.runs as RunData[]) : [],
      routes: Array.isArray(data.routes) ? (data.routes as RouteData[]) : [],
    };
  }

  async function fetchMapData(url: string): Promise<MapData> {
    const response = await fetch(url, { cache: 'force-cache' });
    if (!response.ok) {
      throw new Error(`Map data request failed (${response.status})`);
    }
    const json = await response.json();
    return normalizeMapData(json);
  }

  function initMap() {
    const mapEl = document.getElementById('run-map');
    if (!mapEl) return;

    // Prevent re-initialization after View Transitions (async race condition)
    if ((mapEl as any)._leaflet_id || (mapEl as any).__mapInitPending) return;
    (mapEl as any).__mapInitPending = true;

    const mapDataUrl = (mapEl as HTMLElement).dataset.mapUrl || '/data/run-locations.json';

    fetchMapData(mapDataUrl)
      .then(({ runs, routes }) => {
        if (runs.length === 0) {
          showMapError('No run locations available in map data.');
          return;
        }

        const map = L.map(mapEl, {
          scrollWheelZoom: false,
          zoomControl: true,
          worldCopyJump: false,
          minZoom: 2,
          maxZoom: 20,
        });

        const worldBounds = L.latLngBounds([[-85, -180], [85, 180]]);
        map.setMaxBounds(worldBounds);

        // CARTO Voyager (no labels) — warm tones, no API key needed
        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
          subdomains: 'abcd',
          maxZoom: 20,
        }).addTo(map);

        // ── Route Polylines ──────────────────────────────────────────────
        const routeLayers: L.Polyline[] = [];

        routes.forEach((route) => {
          if (route.coordinates.length < 2) return;

          const polyline = L.polyline(route.coordinates as L.LatLngExpression[], {
            color: '#2D5F3F',
            weight: 2.5,
            opacity: 0.5,
            smoothFactor: 1,
          }).addTo(map);

          polyline.bindPopup(
            `<div class="route-popup">
              <strong class="route-popup-name">${escapeHtml(route.name)}</strong>
              <span class="route-popup-type">Saved Route</span>
            </div>`,
            { className: 'route-popup-container' }
          );

          // Highlight on hover
          polyline.on('mouseover', () => {
            polyline.setStyle({ opacity: 0.9, weight: 4 });
          });
          polyline.on('mouseout', () => {
            polyline.setStyle({ opacity: 0.5, weight: 2.5 });
          });

          routeLayers.push(polyline);
        });

        // ── Run Markers with Clustering ──────────────────────────────────

        // Custom pin icon
        const pinIcon = L.divIcon({
          className: 'run-pin',
          html: `<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="6" cy="6" r="5" fill="#2D5F3F" stroke="#F8F7F4" stroke-width="2"/>
          </svg>`,
          iconSize: [12, 12],
          iconAnchor: [6, 6],
          popupAnchor: [0, -8],
        });

        // Circular photo thumbnail marker for runs with media
        function createPhotoMarkerIcon(mediaSrc: string): L.DivIcon {
          return L.divIcon({
            className: 'run-pin-photo',
            html: `<div class="photo-marker"><img src="/${mediaSrc}" alt="" loading="lazy" /></div>`,
            iconSize: [28, 28],
            iconAnchor: [14, 14],
            popupAnchor: [0, -16],
          });
        }

        const clusterGroup = (L as any).markerClusterGroup({
          maxClusterRadius: 40,
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          iconCreateFunction: function (cluster: any) {
            const count = cluster.getChildCount();
            let size = 'small';
            if (count >= 50) size = 'large';
            else if (count >= 10) size = 'medium';

            return L.divIcon({
              html: `<span>${count}</span>`,
              className: `run-cluster run-cluster-${size}`,
              iconSize: L.point(36, 36),
            });
          },
        });

        // Store markers by run key for gallery interaction
        const markersByRun = new Map<string, L.Marker>();

        runs.forEach((run) => {
          const parsedDate = new Date(run.date);
          const date = Number.isNaN(parsedDate.getTime())
            ? 'Unknown date'
            : parsedDate.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
            });

          // Build photo HTML if media exists — hero photo + thumbnail strip
          let photoHtml = '';
          if (run.media && run.media.length > 0) {
            const images = run.media
              .map((m) => sanitizePopupMediaPath(m))
              .filter((m): m is string => m !== null)
              .filter((m) => m.endsWith('.jpg') || m.endsWith('.jpeg') || m.endsWith('.png'));
            if (images.length > 0) {
              const hero = images[0];
              photoHtml = `<div class="run-popup-media">`;
              photoHtml += `<img src="/${hero}" alt="${escapeHtml(run.name)}" loading="lazy" class="run-popup-hero" />`;
              if (images.length > 1) {
                photoHtml += `<div class="run-popup-thumbs">`;
                images.slice(1, 4).forEach((img) => {
                  photoHtml += `<img src="/${img}" alt="" loading="lazy" class="run-popup-thumb" />`;
                });
                if (images.length > 4) {
                  photoHtml += `<span class="run-popup-more">+${images.length - 4}</span>`;
                }
                photoHtml += `</div>`;
              }
              photoHtml += `</div>`;
            }
          }

          // Build gear tag
          const gearHtml =
            run.gear && run.gear.length > 0
              ? `<span class="run-popup-gear">${escapeHtml(run.gear)}</span>`
              : '';

          const popup = `
            <div class="run-popup">
              ${photoHtml}
              <strong class="run-popup-name">${escapeHtml(run.name)}</strong>
              <span class="run-popup-date">${date}</span>
              <div class="run-popup-stats">
                <span>${formatDistance(run.distance)}</span>
                <span class="run-popup-sep">&middot;</span>
                <span>${formatDuration(run.moving_time)}</span>
                <span class="run-popup-sep">&middot;</span>
                <span>${formatPace(run.distance, run.moving_time)}</span>
              </div>
              ${gearHtml}
            </div>
          `;

          const hasPhotos = run.media && run.media.length > 0;
          const firstImage = hasPhotos
            ? run.media
                .map((m) => sanitizePopupMediaPath(m))
                .find((m): m is string => m !== null && (m.endsWith('.jpg') || m.endsWith('.jpeg') || m.endsWith('.png')))
            : null;
          const icon = firstImage ? createPhotoMarkerIcon(firstImage) : pinIcon;
          const popupOptions = hasPhotos
            ? { maxWidth: 320, minWidth: 260 }
            : { maxWidth: 280, minWidth: 180 };
          const marker = L.marker([run.lat, run.lng], { icon }).bindPopup(popup, popupOptions);

          // Register for gallery lookup
          const runKey = `${run.lat},${run.lng},${run.name}`;
          markersByRun.set(runKey, marker);

          clusterGroup.addLayer(marker);
        });

        map.addLayer(clusterGroup);

        // ── Fit Bounds ───────────────────────────────────────────────────
        const allBounds = L.latLngBounds([]);

        const markerBounds = clusterGroup.getBounds();
        if (markerBounds.isValid()) {
          allBounds.extend(markerBounds);
        }

        routeLayers.forEach((rl) => {
          const rb = rl.getBounds();
          if (rb.isValid()) {
            allBounds.extend(rb);
          }
        });

        if (allBounds.isValid()) {
          map.fitBounds(allBounds, { padding: [40, 40], maxZoom: 12 });
        }

        // Enable scroll zoom on first click
        map.on('click', () => {
          map.scrollWheelZoom.enable();
        });

        // Listen for gallery focus events
        window.addEventListener('gallery:focus-run', ((event: CustomEvent) => {
          const { lat, lng, name } = event.detail;
          const key = `${lat},${lng},${name}`;
          const marker = markersByRun.get(key);

          if (marker) {
            map.setView([lat, lng], 13, { animate: true });
            setTimeout(() => {
              (clusterGroup as any).zoomToShowLayer(marker, () => {
                marker.openPopup();
              });
            }, 300);
          }
        }) as EventListener);
      })
      .catch((error: unknown) => {
        const message = error instanceof Error ? error.message : 'Unknown map data error';
        showMapError(`Map data could not be loaded: ${message}`);
      });
  }

  // Initialize on page load and after View Transitions
  document.addEventListener('astro:page-load', initMap);
</script>

<style>
  .map-wrapper {
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--color-border);
    background-color: var(--color-surface);
  }

  #run-map {
    width: 100%;
    height: 420px;
  }

  .map-error {
    padding: var(--space-md);
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    border-top: 1px solid var(--color-border);
    margin: 0;
  }

  @media (min-width: 640px) {
    #run-map {
      height: 480px;
    }
  }

  @media (min-width: 1100px) {
    #run-map {
      height: 560px;
    }
  }

  /* Custom pin marker */
  :global(.run-pin) {
    background: transparent !important;
    border: none !important;
  }

  /* Circular photo thumbnail marker */
  :global(.run-pin-photo) {
    background: transparent !important;
    border: none !important;
  }

  :global(.photo-marker) {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    overflow: hidden;
    border: 2.5px solid #2D5F3F;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  :global(.photo-marker:hover) {
    transform: scale(1.15);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  :global(.photo-marker img) {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  /* Cluster styles */
  :global(.run-cluster) {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 600;
    color: #F8F7F4;
    background-color: #2D5F3F;
    border: 2px solid #F8F7F4;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  }

  :global(.run-cluster-small) {
    width: 32px;
    height: 32px;
    font-size: 11px;
  }

  :global(.run-cluster-medium) {
    width: 40px;
    height: 40px;
    font-size: 12px;
  }

  :global(.run-cluster-large) {
    width: 48px;
    height: 48px;
    font-size: 13px;
  }

  /* Popup styles */
  :global(.run-popup) {
    font-family: "Iowan Old Style", "Apple Garamond", "Baskerville",
      "Times New Roman", serif;
    line-height: 1.5;
  }

  :global(.run-popup-name) {
    display: block;
    font-size: 14px;
    color: #1A1A1A;
    margin-bottom: 2px;
  }

  :global(.run-popup-date) {
    display: block;
    font-size: 12px;
    color: #6B7280;
    margin-bottom: 6px;
  }

  :global(.run-popup-stats) {
    font-size: 12px;
    color: #2D5F3F;
    font-weight: 500;
  }

  :global(.run-popup-sep) {
    margin: 0 4px;
    color: #D1CFC7;
  }

  :global(.run-popup-gear) {
    display: inline-block;
    margin-top: 6px;
    font-size: 11px;
    color: #6B7280;
    background: #F0EFEB;
    padding: 1px 8px;
    border-radius: 10px;
  }

  /* Hero photo popup styles */
  :global(.run-popup-media) {
    margin: -10px -14px 10px -14px;
    overflow: hidden;
  }

  :global(.run-popup-hero) {
    width: 100%;
    max-height: 200px;
    object-fit: cover;
    display: block;
  }

  :global(.run-popup-thumbs) {
    display: none;
    gap: 2px;
    margin-top: 2px;
  }

  :global(.run-popup-thumb) {
    flex: 1;
    height: 48px;
    object-fit: cover;
    display: block;
  }

  :global(.run-popup-more) {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    height: 48px;
    background: #F0EFEB;
    font-family: var(--font-mono);
    font-size: 11px;
    color: #6B7280;
  }

  @media (min-width: 640px) {
    :global(.run-popup-thumbs) {
      display: flex;
    }
  }

  /* Route popup styles */
  :global(.route-popup-name) {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: #1A1A1A;
    font-family: "Iowan Old Style", "Apple Garamond", "Baskerville",
      "Times New Roman", serif;
  }

  :global(.route-popup-type) {
    display: block;
    font-size: 11px;
    color: #2D5F3F;
    font-weight: 500;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    margin-top: 2px;
  }

  /* Override Leaflet popup styles */
  :global(.leaflet-popup-content-wrapper) {
    border-radius: 6px !important;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1) !important;
    padding: 0 !important;
  }

  :global(.leaflet-popup-content) {
    margin: 10px 14px !important;
    font-size: 13px !important;
  }

  :global(.leaflet-popup-tip) {
    box-shadow: none !important;
  }

  /* Override default MarkerCluster styles */
  :global(.marker-cluster-small),
  :global(.marker-cluster-medium),
  :global(.marker-cluster-large) {
    background-color: transparent !important;
  }

  :global(.marker-cluster-small div),
  :global(.marker-cluster-medium div),
  :global(.marker-cluster-large div) {
    background-color: transparent !important;
  }
</style>
